{"meta":{"title":"UyoAhz","subtitle":"赵某某的Blog","description":"赵某某Blog,咱赵某人自己的Blog,","author":"UyoAhz","url":"https://uyoahz.cn"},"pages":[{"title":"关于","date":"2018-12-12T14:14:36.000Z","updated":"2021-06-23T13:30:44.200Z","comments":false,"path":"about/index.html","permalink":"https://uyoahz.cn/about/index.html","excerpt":"","text":"[UyoAhz]正在与&nbsp;UyoAhz&nbsp; （ ） 对话中...bot_ui_ini()本人擅长Ai、Fw、Fl、Br、Ae、Pr、 Id、Ps等软件的安装与卸载，精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal等单词的拼写，熟悉Windows、Linux、Mac、Android、IOS、WP8等系统的开关机。本人学识渊博、经验丰富，代码风骚、效率恐怖, C/C++、java、php无不精通,熟练掌握各种框架,深山苦练20余年，每天只睡4个小时，千里之外定位问题，瞬息之间修复上线。身体强壮、健步如飞，可连续编程100小时不休息，讨论技术方案5小时不喝水，上至带项目、出方案，下至盗账号、威胁PM，啥都能干。泡面矿泉水已准备好，备用电源、万兆光纤永不断电断网，门口已埋雷无人打扰，欢迎各位大佬~","keywords":"关于"},{"title":"追番列表","date":"2019-02-10T13:32:48.000Z","updated":"2021-05-14T11:11:54.767Z","comments":false,"path":"bangumi/index.html","permalink":"https://uyoahz.cn/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"留言","date":"2018-12-20T15:13:48.000Z","updated":"2021-06-19T12:23:18.510Z","comments":true,"path":"comment/index.html","permalink":"https://uyoahz.cn/comment/index.html","excerpt":"","text":"念两句诗叙别梦、扬州一觉。【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"叨叨","date":"2018-12-20T15:13:48.000Z","updated":"2021-06-06T08:35:09.890Z","comments":true,"path":"daodao/index.html","permalink":"https://uyoahz.cn/daodao/index.html","excerpt":"","text":"ispeakBber.init({el:\"#speak\",name:\"UyoAhz 📢\",envId:\"bber-2g6eo6w3a44db02e\",region:\"ap-shanghai\",limit:10,avatar:\"https://cdn.jsdelivr.net/gh/Uyoahz26/cdn@master/img/custom/avatar.jpg\",fromColor:\"rgb(245, 150, 170)\",loadingImg:\"https://7.dusays.com/2021/03/04/d2d5e983e2961.gif\",dbName:\"talks\"}).then(function(){console.log(\"小赵叨叨 加载完成\")})","keywords":"小赵叨叨，意想不到。"},{"title":"友链","date":"2018-12-19T15:11:06.000Z","updated":"2021-06-23T14:04:00.329Z","comments":true,"path":"links/index.html","permalink":"https://uyoahz.cn/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"音乐","date":"2018-12-20T15:14:28.000Z","updated":"2021-06-19T12:36:38.462Z","comments":false,"path":"music/index.html","permalink":"https://uyoahz.cn/music/index.html","excerpt":"","text":"QQ音乐","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-15T19:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://uyoahz.cn/rss/index.html","excerpt":"","text":""},{"title":"标签云","date":"2021-05-19T10:46:28.000Z","updated":"2021-05-22T03:39:25.756Z","comments":false,"path":"tags/index.html","permalink":"https://uyoahz.cn/tags/index.html","excerpt":"","text":"","keywords":null}],"posts":[{"title":"实习....","slug":"实习","date":"2021-07-22T11:22:01.000Z","updated":"2021-07-22T11:33:54.947Z","comments":true,"path":"2021072258082/","link":"","permalink":"https://uyoahz.cn/2021072258082/","excerpt":"","text":"实习遇到了牛逼的人，嚣哥yyds…","categories":[],"tags":[],"keywords":[]},{"title":"Win11 新版Office初体验","slug":"Win11-新版Office初体验","date":"2021-07-07T07:24:34.000Z","updated":"2021-07-08T09:37:57.929Z","comments":true,"path":"2021070729579/","link":"","permalink":"https://uyoahz.cn/2021070729579/","excerpt":"","text":"Windows11i3古董机，磁盘容量不大，已经满了，本来就有重装系统的想法，结果微软直接发布11，我™直接冲古董机都能装11啦，管他什么限制什么要求，打开PE就是一顿装，硬装先放几张图片(多图警告⚠)任务栏居然居中了，爷青结~整体看上去果里果气的，整体感觉还行，毕竟机子性能不太行，跑起来略有卡顿俗话说的好，一帧能玩，两帧流畅，三帧电竞，更何况我60帧呢，手动狗头内存占用路确实少了点，以前开几个软件就剩2G了，现在泪目了，家人们，居然还有2.6G！！！古董机！！！！！整体UI比10好看了不少，动画也更丝滑，丝滑的不像Windows，系统动效和全新的音效都不错。日用没问题，我是没遇到什么Bug，大的小的都没有，不过机子确实性能跟不上了，在设置里面打开有的选项有点卡顿，需要等个两三秒才能反应过来。整体感觉不错，毕竟才是第一版，等后续优化吧。新版Office365随着windows11的更新，Office也引来了一波更新，改了UI，个人感觉变好看了，但是额头部分略大，对小屏幕不太友好。上图微软换设计师了？？？？加上白嫖的Office E5 开发者试用，再配合上浅忆开发E5自动续订程序，香的不能再香了。有需要的留言邮箱前缀，留言时记得填写邮箱一栏，发你账号密码最好是能经常使用Offic比较活跃的用户。","categories":[],"tags":[{"name":"Win11","slug":"Win11","permalink":"https://uyoahz.cn/tags/Win11/"}],"keywords":[]},{"title":"JAVA基础","slug":"JAVA基础","date":"2021-07-02T10:27:57.000Z","updated":"2021-07-08T09:38:52.247Z","comments":true,"path":"2021070233701/","link":"","permalink":"https://uyoahz.cn/2021070233701/","excerpt":"","text":"byte 1字节short 2字节int 4字节long 8字节char 2字节（C语言中是1字节）可以存储一个汉字float 4字节double 8字节boolean false/true(理论上占用1bit,1/8字节，实际处理按1byte处理)JAVA是采用Unicode编码。每一个字节占8位。你电脑系统应该是 32位系统，这样每个int就是 4个字节其中一个字节由8个二进制位组成Java一共有8种基本数据类型（原始数据类型）：类型 存储要求 范围（包含） 默认值 包装类整 int 4字节（32位） -231~ 231-1 0 Integer数 short 2字节（16位） -215~215-1 0 Short类 long 8字节（64位） -263~263-1 0 Long型 byte 1字节（8位） -27~27-1 0 Byte浮点 float 4字节（32位） -3.4e+38 ~ 3.4e+38 0.0f Float类型 double 8字节（64位） -1.7e+308 ~ 1.7e+308 0 Double字符 char 2字节（16位） u0000~uFFFF（‘’~‘？’） ‘0’ Character（0~216-1（65535））布尔 boolean 1/8字节（1位） true, false FALSE Boolean关键字访问控制private、public、protected、default类、方法、变量修饰符abstract（抽象类）、class、extends、final、implement、interface、native、new、static、stricfp、synchronized、transient、volatile程序控制break、continue、return、do、while、if、else、for、instanceof、 switch、case、default异常处理try、catch、throw、throws包相关import、package基本类型boolean、byte、char、double、float、int、long、short、null、true、false变量引用super、this、void保留字goto、const类的加载顺序1.首先，需要明白类的加载顺序。(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)(3) 父类非静态代码块(包括非静态初始化块，非静态属性)(4) 父类构造函数(5) 子类非静态代码块(包括非静态初始化块，非静态属性)(6) 子类构造函数其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)","categories":[],"tags":[],"keywords":[]},{"title":"集合、数据结构","slug":"集合、数据结构","date":"2021-06-27T06:29:30.000Z","updated":"2021-07-08T09:26:08.765Z","comments":true,"path":"2021062743798/","link":"","permalink":"https://uyoahz.cn/2021062743798/","excerpt":"","text":"list、set、map的区别：list和set都实现了collection接口List:允许重复、可以有多个null元素、有序（输出的顺序就是插入的顺序）：ArrayList、LinkedList、Vectorset:不允许重复对象、无序排序、只允许有一个空元素：HashSet、LinkedHashSet、treeSetMap:Map是一个接口，Map可以有多个null值但最多只能有一个null键：HashMap、Hashtable 、TreeMapArrayList、LinkedList和Vector的区别:​ ArrayList：通过索引，访问速度快​ LinkedList: LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据 时只需要记录本项前后项即可，插入数据较快​ Vector：线程安全， Vector由于使用了synchronized方法-线程安全，所以性能上比ArrayList要差HashMap、 Hashtable和TreeMap的区别：​ 这三个都对Map接口进行了实现：HashMap是不安全的线程，他允许Key值出现一次null，Value值出现无数次的NullHashtable是安全的线程，他不仅实现了Map接口也实现了Dictionary接口，他的key值与Value值都不允许出现NulltreeMap是可以进行排序的，默认按照键的自然顺序进行升序排序，若要进行降序排序则需要在构造集合时候传递一个比较器Hashtable和HashMap 的区别：HashTable的方法是同步的，HashMap未经同步，所以在多线程场合要手动同步HashMap这个区别就像Vector和ArrayList一样。HashTable不允许null值，key和value都不可以,HashMap允许null值，key和value都可以。HashMap允许key值只能由一个null值，因为hashmap如果key值相同，新的key, value将替代旧的。HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。HashTable使用Enumeration，HashMap使用Iterator。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。哈希值的使用不同，HashTable直接使用对象的hashCode。什么场景下使用list,set,map?如果经常会使用索引来对容器中的元素进行访问，那么 List 是正确的选择。如果已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。如果想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。如果你保证插入元素的唯一性，也就是不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。如果以键和值的形式进行数据存储那么 Map 是正确的选择。可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。HashMap 和 Hashtable 的区别？线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果要保证线程安全的话就使用 ConcurrentHashMap ）；效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。初始容量大小和每次扩充容量大小的不同 ：①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。HashMap 和 HashSet区别？HashMap的底层实现？HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。 只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树。在调用 HashMap 的 put 方法添加元素时，会对key的hashCode()做hash运算，计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。在调用 HashMap 的 get 方法获取元素时，会对key的hashCode()做hash运算，计算index; 如果在bucket里的第一个节点里直接命中，则直接返回； 如果有冲突，则通过key.equals(k)去查找对应的Entry。ArrayList和LinkedList的区别是什么 ？ArrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 0(1)，而 LinkedList 是 0(n)ArrayList 和 Vector 的区别是什么？Vector 使用了 synchronized 来实现线程同步，是线程安全的，而ArrayList 是非线程安全的。Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 0.5 倍。HashMap 和 HashTable 的区别？HashMap 允许空值键，HashTable 不允许。HashMap 线程不安全（效率高），HashTable 线程安全。","categories":[],"tags":[{"name":"集合","slug":"集合","permalink":"https://uyoahz.cn/tags/集合/"},{"name":"数据结构","slug":"数据结构","permalink":"https://uyoahz.cn/tags/数据结构/"}],"keywords":[]},{"title":"Linux复习题","slug":"Linux复习题","date":"2021-06-19T07:20:20.000Z","updated":"2021-06-19T12:52:33.634Z","comments":true,"path":"2021061926657/","link":"","permalink":"https://uyoahz.cn/2021061926657/","excerpt":"","text":"Linux复习题一、填空题硬盘sdb2的含义是 第二个SCSI硬盘的第二个逻辑分区编号 ；hdb5的含义是 第二个IDE硬盘的第一个逻辑分区编号 。LINUX的组成： 内核 、shel1、 文件系统 、LINUX应用系统。在 linux下查看文件内容的分页命令包括：1ess 和 more ，查看网络配置的命令是 ifconfig ，测试网络连通的命令是 ping 。OpenOffice.org Writer 的功能和 aicrosoft office 的 word 功能相似，OpenOffice.org Calc 的功能和 microsoft office 的 excel 功能相似。OpenOffice.org Impress 和microsoft office 的 PowerPoint 功能相似。1s显示该目录下的内容，白色背景色下，其中压缩文件为 红 色， 目录 为蓝色，普通文件为 白 色， 可执行文件 为绿色。Linux中，[！0-9]表示 非0-9 ，[1，5]表示 参数1和5 。以下特殊目录的含义：~表示 用户家 目录，..表示 父 目录。Linux 操作系统中 root的提示符为 # ，普通用户的提示符为 $ 。Linux 操作系统有三部分组成，它们分别是： 内核 、 shell 和文件结构。Linux 下的文件类型有 5 种： 普通文件 、 目录文件 、 设备文件 、链接文件和管道文件。Linux系统中,若文件权限为rwxrw-rw-.其中r代表 只读 、w代表 写 、x代表 可执行 .Linux 系统中，查看某一个网络接口状况使用 ifconfig 命令，测试本地主机是否能与另一台主机交换数据使用 ping 命令。[root@loolhost]#中，root 为 根用户 ，表示当前用户为root；@表示at(在、属于)；localhost表示 主机 ；“表示root的 root的家目录 。在shell中有三种变量分别是： 系统 、 环境 、 用户 。Linux文件颜色的含义：蓝色代表目录， 白色 代表普通文件， 绿色 代表可执行文件，红色表示压缩文件用GCC编译程序的四个步骤为：预处理、编译、 汇编 和 链接 。二、选择题下面关于Linux的描述错误的是【 D 】A.支持图形化界面操作 B.多任务 C.具有丰富的网络功能 D.单用户若要将鼠标从VM中释放出来，可按【 B 】键来实现。A.Ctrl-Shift B.Ctrl+Alt C.Ctrl+Enter D. Ctrl+delLinux分区中，用于存放系统配量文件的目录是【 A 】A./etc B./home C./var D./rootLinux下添加用户命令是【 C 】A.usermod B.userdel C.useradd D.groupadd在Linux中，标识接在IDE0上的slave硬盘的第2个扩展分区的是【 C 】A./dev/hdb2 B./dev/hdlb2 C./dev/hdb6 D./dev/hdlb6root的UID通常是【 D 】A.3 B.2 C.1 *D.0若某文件访问权限是“-rw-w—r—”则文件所有者拥有【 A 】权限A.读写权限 B.执行权限 C.写权限 D.只读将普通用户转换为超级用户的命令是【 B 】A.passwd B.us C.tar D.car下面可以把fl.txt复制为f2、txt的命令是【 C 】A.cp f1.txt | f2.txt B.cat f1.txt | f2.txt C.cat f1.txt &gt; f2.txt D.copy f1.txt | f2.txt快速切换到用户John的主目录下使用【 D 】命令A. cd @John B. cd #John C.cd &amp;John D.cd ~John在vi中退出不保存的命令是？【 D 】A. :q B. :w C. :wq D. :q!如果未进行指定输出文件名，gec的译出来的程序后缀是一个名为【A】的可执行文件。A. a.out B. a.gcc C. a.gdb D. .c要终止一个用户的所有进程，应使用的命令是【D】A.skill B.skillall C.kill D.killallLinux用于检测本机各端口连接情况的命令是【C】A.ping B.route C.netstat D.ifconfigLinux系统中，一般把命令ls定义为ls–color的别名，以便以不同颜色来标识不同类型的文件、但是，如何能够使用原先的ls命令？【A】A. \\ls B. :1s C. ls $$ D.ls –noaliasApache的主配置文件是：【A】A.httpd.conf B.httpd.cfg C.access.ofg D. apache.conf下面不合法的变量名是【C】A.Kitty B.b00k C.Hello World D.mpic_game下面可以迅速终止前台运行进程的快捷键是【B】A.Ctrl+A B.Ctrl+C C.Ctrl+Q D.Ctrl+Z在Linux系统中的脚本文件一般以【B】开头A.S/bin/sh B.#!/bin/sh C.use/bin/sh D.set shell=/bin/sh对于Apache服务器，提供的子进程的缺省的用户是【D】A. root B. apached C.httpd D.nobody存放用户帐号密码的文件是（C ）A.shadow B. group C.passwd D. gshadow普通用户的主目录是（ D）A./bin B./dev C./boot D./homeLinux系统的联机帮助命令是（D ）A. tar B.cd C.mkdir D.man如何删除一个非空子目录/tmp（B ）A.del /tmp/ B.rm -rf /tmp C.rm -Ra /tmp/ D.rm -rf /tmp/*更改一个文件权限的命令是（ C）A.change B.attrib C.chmod D.at如果执行命令#chmod 764 file.txt，那么该文件的权限是（D ）A.rwxr–rw- B.rw-r–r– C.–xr–rwx D.rwxrw-r–列出当前目录以及子目录下所有扩展名为“.txt”的文件，使用的命令是（ B）A. ls *.txt B.find -name“.txt” C.ls -d.txt D.find.“.txt”显示当前工作目录的命令是（A ）A. pwd B. cd C. who D. ls把当前目录下的f20201.txt复制为f20202.txt，正确操作的是（D ）。A.copy f20201.txt f20202.txt B.cp f20201.txt | f20202.txtC.cat f20202.txt f20201.txt D.cat f20201.txt &gt; f20202.txt文件的所有者有读(r)和写(w)的权限，其他用户只有读的权限，权限值为（B）A.566 B.644 C.655 D.744为了将当前目录下的压缩归档文件myftp.tar.gz解压缩，可以使用（ A）A.tar -xvzf myftp.tar.gz B.tar -xvz myftp.tar.gzC.tar -vzf myftp.tar.gz D.tar -xyf myftp.tar.gz用来保存用户名、个人目录等信息的文件是（B ）A./etc/shadow B./etc/passwd C./etc/inittab D./etc/group一个文件的权限是-rw-rw-r–，这个文件的同组用户的权限是（C）A. read-only B. write C.read-write D.write-only删除目录的命令是（D）A. del B.delete C.cut D.rmdir在Linux系统中，硬件设备大部分是安装在（B）目录下的A./mnt B./dev C./proc D./swap不属于对进程直接操作的命令是（D）A.ps B.top C.kill D.cat要改变文件的拥有权，使用命令（B）A.chgrp B.chown C.chsh D.chmod在给定文件中查找与设定条件相符字符申的命令为：（A）A. grep B.gzip C.find D.sort温出交互模式的shell，应键入（C）A.\\B.CTRL+q C.exit D.quit当我们与某远程网络连接不上时，就需要眼踪路由查看，以便了解在网络的什么位置出现了问题，满足该且的的命令是（C）A.ping B.ifconfig C.traceroute D.netstat三、简答题1. 简述Linux操作系统与windows操作系统的区别。​ Linux 操作系统与Windows操作系统的设计思路不同：Windows设计目的是让用户更友好的使用系统，得到最好的用户体验：而Linux则聚信在内涵，力求做出量专业的系统。Windows是商业化系统==，用户道及全球；Linux是专业式系统：对用户不够友好.2. Linux有哪些典型应用领域?并举例说明。典型应用领域包括三个方面：桌面应用领域：Linux在图形用户接口和桌面应用领域软件方面的发展得到显著提高，能够满足用户办公、娱乐和信息交流的需求。高端服务器领域：Linux在服务器市场上占有率已超50%，Linux服务器可以充当虚拟专用阿、略由器与网关。嵌入式应用领域：许多厂商在基于lntel架构中采用Linux开发视领电话和数字监控等系统3. Vi（Vim）有哪几种模式?模式之间如何切换？三种模式：命令模式、输入模式、末行模式三种模式转换：从命令模式转到文本输入模式，可以输入命令 a 或 i 。如果从文本输入模式返回，则按【Esc】键即可。。在命令模式下输入“：”即可切换到末行模式。4. 目录操作在“/”下新建一个dir2020目录在“dir2020”下再新建一个目录“test2020”，在“/test2020”建立一个“hi2020”目录。写出建立各级目录的过程和删除“/hi2020”目录的过程（包括完整的命令）。cd/mkdir dir2020cd test 2020 lnkdir test2020cd test2020 mkdir hi2020rmdir -p/dir2020/test2020/hi20205.vim编辑器使用​ 用vim编写一个文件，名称是abc2020.doc，首先录入文件内容：“Today is special day！”，保存。然后进行追加内容“I have a good time”。写出编辑的整个过程。（包括运行的完整命令）在slhell命令提示符后输入“vi”、启动vi编辑器。按 i 键切换到文本编辑模式并输入内容：“Today is special day！”按 Esc 键返回命令行模式，再按：键进入末行模式，输入“abc2020.doc”保存，按 q 键退出 vi输入“vi abc2020.doc”，启动 vi 并打开文件，按 a 键并输入“I have a good time”，按：键进入末行模式，输入“：qw”保存并退出。6.压缩包操作​ 在目录/test下有一个文件，其名称为file2020.txt，要求将其进行压缩，并在“/”下新建一个目录“/test2020”，将压缩后的文件复制到该目录下，并将该文件解压至到/test2020目录下。写出整个操作过程。（包括运行的完整命令）cd/testgzip file2020.txtcd/ mkdir test2020mv /test file2020.txt.gz /test2020cd test2020 gzip -d file2020.txt7.Shell编程用shell编程实现：1+2+…+100。要求：（1）shell编程步骤清晰：（2）遵守 shell语法：（3）写出迹程序的执行过程及运行给果。#!/bin/bash i=1 sum=0 while [$i -le 100];do sum =$[$sum+$i] i= $[$i+1]. done echo $sum 执行： chmod u-x abc, bash abc 或 . abc结果：5050","categories":[],"tags":[{"name":"复习题","slug":"复习题","permalink":"https://uyoahz.cn/tags/复习题/"}],"keywords":[]},{"title":"观《觉醒年代》后感","slug":"觉醒年代","date":"2021-05-29T11:18:14.000Z","updated":"2021-07-08T09:26:08.772Z","comments":true,"path":"2021052910218/","link":"","permalink":"https://uyoahz.cn/2021052910218/","excerpt":"","text":".cd-top{background:url(https://cdn.jsdelivr.net/gh/Uyoahz26/ImgBed@main/img20210531184353.png) no-repeat center}先看两个片段1、毛润之出场他踏散的是一沟死水（闻一多《死水》），泥泞的道路上走着鱼贩（小商贩）、农民（被牵着走的老牛）、乞丐和可怜的孩子（社会最底层）还有军阀，车里和楼上有鲁迅笔下的看客（zc阶级的少爷、小姐），有一个盲人拄着棍走（黑暗中摸索的人）……他将一切尽收眼底，不畏风雨，亦不怕道路崎岖，怀中抱着的是中国未来（《新青年》杂志）走过了这条路背景音乐从他的出场发生了变化，寓意着他登上历史舞台后会发生什么。这两分钟的镜头可以称的上艺术级了。太🐂🍺了。2、蔡元培北大任职演讲这段台词就是当年蔡元培任职北大校长时演讲稿，一字不差。这篇演讲完全不像是一百年前的，放到今天也完全适用。再看看导演的神仙选角鲁迅蔡元培胡适毛泽东李大钊正在演讲的李大钊赵世炎钱玄同等《觉醒年代》作为建党100周年的献礼剧，一经播出就广受好评。这部剧以李大钊、陈独秀等历史人物为主要角色，着重展现了1915年到1921年中国共产党成立之前的这段历史。从袁世凯签署“二十一条”到《新青年》创刊，从五四运动到中国共产党成立，那段国运飘摇、民不聊生的艰难时世在剧中全方位展现。让不怎么了解历史的我，看完之后（虽然现在还没看完）对这段历史有了清晰的认知，整部剧有喜有悲。乐的时候挺乐的，泪的时候真叫人热泪盈眶。而且整部剧的镜头语言可以说真的太🐂🍺了，有的画面没台词，却胜过千言万语。真的是“此时无声胜有声”。一个字，绝。看了之后对蔡元培（字孑名）、陈独秀（仲甫）、李大钊（字守常）、鲁迅（字豫才）等人有了更清晰的认识。不得不说蔡元培真的是全中国最好的校长，以前不了解更不知道有蔡元培这么个人，现在才发现，若不是蔡元培，可能就没有现在的中国。还有鲁迅，终于知道中国的第一篇白话文小《狂人日记》是在什么样的背景下诞生的，有着怎样的影响力，相当震撼。我们站在历史后来人的视角看先辈们，感觉到他们伟大。但他们的伟大和悲壮远比我们所能想象深重得多。因为我们看见了他们的胜利所以能感受到他们的奋斗意义重大,而他们在牺牲之时并不能预知未来，不知道自己的牺牲对中国的胜利有多大意义，也不知道我们要用多少年才能迎来胜利，甚至不确定我们能不能胜利。他们抱着一腔热血，在牺牲之时所能依赖的只有满怀的信念。我一想这样的场景就想哭，太悲壮了。曾经我一度想不通为什么有人要当汉奸。当别人的走狗，爬得再高也不过是啃骨头的狗，哪有什么地位可言?有些人明明也是饱读诗书的有识之士，为什么不能直起身板做人，非要做汉奸当狗。后来有一天和人又聊起这个话题，他说，他们又不知道中国能扛过去。我在那一刻才突然醒悟了一个问题,是啊，他们不知道。我以一个后人的视角回看历史时，原来已经不知不觉间忘记了，当时的人并不知道中国真的能取得最终的胜利，能再度成为一个完全独立自主的国家。在那样国土沦丧的背景下，最终胜利，才更像是痴人说梦。原来我们今天所习以为常的一切,并不是历史进程的必然结果。当汉奸的人想不到会有今天。而成为英雄,成为烈士的那些人，其实，他们大约也是想不到的。到那一天我才突然明白，原来“不做亡国奴”不是必然结果，“抗争胜利”并不是必然结果，“建立独立自强的中国”也并不是必然结果….……原来那些人说着“我们一定会获得最终胜利”时,并不真正的知道，他们真的能成功。原来他们前赴后继地牺牲的时候，也并不真正的确定,他们的牺牲是不是能换来他们想要的结果。原来“坚定的信仰”，是这个意思。原来我一直知道他们伟大,却依然低估了他们的伟大。《觉醒年代》虽好，但也只是一部电视剧，不是真实历史，虽然把1915到1921这段激荡的岁月呈现在国人的眼前了，那也只是艺术的还原，希望大家不要把电视剧当历史了。这也偏离了创作团队的创作初衷。只能说真的太牛了。最后分享几个经典台词遍地哀鸿满城血，无非一念就苍生。天下的路是给天下人走的，有志者事竟成。在这个浮躁的时代，只有自律的人，才有可能脱颖而出，成就大事。江山代有才人出，各领风骚数百年。生逢乱世，即使命运如蝼蚁，但仍有人心向阳光。他们可以抵挡天上的太阳，但他们无法挡住民主的光芒。让我们的子孙后代，享受前人披荆斩棘换来的幸福吧！地球即成白首，吾人尚在青春，以吾人之青春。柔化地球之白首，虽老犹未老也。文明其思想，野蛮其体魄，心力体力合二为一，世上事未有不成。无论我们当什么，我们要当一个堂堂正正的人。在这个浮躁的社会，只有自律的人，才有可能脱颖而出，成就大事!道德是变化的，真理是永恒的。道德是用来律己的，不是用来责人的。自信是优点，但不能盲目自信。我在用我的人生经验与你共勉。后人怎么看我们并不重要，重要的是我们自己是不是问心无愧。","categories":[],"tags":[{"name":"观后感","slug":"观后感","permalink":"https://uyoahz.cn/tags/观后感/"}],"keywords":[]},{"title":"缅怀，国之脊梁！","slug":"国士无双","date":"2021-05-22T06:00:38.000Z","updated":"2021-06-19T12:38:00.031Z","comments":true,"path":"2021052218174/","link":"","permalink":"https://uyoahz.cn/2021052218174/","excerpt":"","text":"html{-webkit-filter:grayscale(100%)}杂交水稻之父 中华拓荒人 –袁隆平“ 我毕生追求就是让所有人远离饥饿。” ——袁隆平 老人家曾有个梦，高产稻比高粱还高，稻穗有扫把那么长，籽粒有花生那么大，自己在禾下乘凉。为了实现这样的梦，袁隆平将一生献给了老百姓的“饭碗”。如今，他带着梦的 “种子” 去了远方，却将粮食的种子、创新与奋斗的 “种子” 留给了后来人。阎王：袁公，该走了，神农公，徐光启公正在等着和你把酒言欢。袁公：再等等，让孩子们安心吃完这顿中饭吧。有幸活在有袁老的时代，见证了一代伟人的奇迹。一路走好…中国肝胆外科之父 –吴孟超“当你们帮助别人时，请记得医药是有时穷尽的，唯有不竭的爱能照亮一个受苦的灵魂。” ——吴孟超 ​ ​​吴孟超，一个极其普通的名字，普通到我从未听说过，但又是一个需要我们记住的名字，关键时刻，能救人一命。他有着一双神奇的手，由于拿了70年的手术刀，导致双手已经严重变形。他还有一双特殊的脚，由于手术长时间站立，他的脚趾已经不能正常并拢。就是这样一个普普通通的老军医，不仅是中科院院士，还是中国当之无愧的肝脏外科之父。在吴老的眼中，如果一个医生对病人不负责任，那就失去了做医生的基本资格。因为作为医生，就是要一切为病人服务！医者仁心，先生一路走好。以后一定会将你们的故事讲述给我们的孩子听，逝者安息，生者图强。山河同悲，日月同泣，愿先生走好。","categories":[],"tags":[],"keywords":[]},{"title":"前端面试题 1","slug":"前端面试题-1","date":"2021-05-12T11:11:06.000Z","updated":"2021-07-08T09:26:08.766Z","comments":true,"path":"2021051258943/","link":"","permalink":"https://uyoahz.cn/2021051258943/","excerpt":"","text":"1、Jq中get和eq有什么区别？get() :取得其中一个匹配的元素。num表示取得第几个匹配的元素，get多针对集合元素，返回的是DOM对象组成的数组 eq():获取第N个元素，下标都是从0开始，返回的是一个JQuery对象2、页面可见性（Page Visibility）API 可以有哪些用途1、 通过visibility state的值得检测页面当前是否可见，以及打开网页的时间。2、 在页面被切换到其他后台进程时，自动暂停音乐或视频的播放。3、同步异步?1、 进程同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事2、 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。4、undefined 和 null 有什么区别？在理解 undefined 和 null 的差异之前，我们先来看看它们的相似点。它们都属于 JavaScript 的 7 种基本类型。let primitiveTypes = [&#39;string&#39;,&#39;number&#39;,&#39;null&#39;,&#39;undefined&#39;,&#39;boolean&#39;,&#39;symbol&#39;, &#39;bigint&#39;]; 它们是属于 falsy 值类型，可以使用 Boolean(value) 或 !!value 将其转换为布尔值时，值为false。console.log(!!null); // false console.log(!!undefined); // false console.log(Boolean(null)); // false console.log(Boolean(undefined)); // false 接着来看看它们的区别。undefined 是未指定特定值的变量的默认值，或者没有显式返回值的函数，如：console.log(1)，还包括对象中不存在的属性，这些 JS 引擎都会为其分配 undefined 值。let _thisIsUndefined; const doNothing = () =&gt; {}; const someObj = { a : &quot;ay&quot;, b : &quot;bee&quot;, c : &quot;si&quot; }; console.log(_thisIsUndefined); // undefined console.log(doNothing()); // undefined console.log(someObj[&quot;d&quot;]); // undefined null 是『不代表任何值的值』。null是已明确定义给变量的值。在此示例中，当fs.readFile方法未引发错误时，我们将获得null值。fs.readFile(&#39;path/to/file&#39;, (e,data) =&gt; { console.log(e); // 当没有错误发生时，打印 null if(e){ console.log(e); } console.log(data); }); 在比较null和undefined时，我们使用==时得到true，使用===时得到false:console.log(null == undefined); // true console.log(null === undefined); // false 5、你对line-height是如何理解的？1、 行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。2、 单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。3、 多行文本垂直居中：需要设置display属性为inline-block。6、什么是移动端的300ms延迟？什么是点击穿透？解决方案?移动端300ms延迟：假定这么一个场景。用户在 浏览器里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，浏览器 就等待 300 毫秒，以判断用户是否再次点击了屏幕。也就是说，当我们点击页面的时候移动端浏览器并不是立即作出反应，而是会等上一小会儿才会出现点击的效果。点击穿透：假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。这是因为在移动端浏览器，事件执行的顺序是touchstart touchend click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。300ms延迟解决方案：(1) 禁用缩放，在html文档头部加meta标签如下：(4) FastClick为解决移动端浏览器300毫秒延迟开发的一个轻量级的库点击穿透解决方案：（1）只用touch（2）只用click（3）tap后延迟350ms再隐藏mask（4）pointer-events7、如何在不使用%模运算符的情况下检查一个数字是否是偶数？我们可以对这个问题使用按位&amp;运算符，&amp;对其操作数进行运算，并将其视为二进制值，然后执行与运算。function isEven(num) { if (num &amp; 1) { return false } else { return true } }0 二进制数是 000 1 二进制数是 001 2 二进制数是 010 3 二进制数是 011 4 二进制数是 100 5 二进制数是 101 6 二进制数是 110 7 二进制数是 111以此类推…因此，当我们执行console.log(5&amp;1)这个表达式时，结果为1。首先，&amp;运算符将两个数字都转换为二进制，因此5变为101，1变为001。然后，它使用按位怀运算符比较每个位（0和1）。101&amp;001，从表中可以看出，如果a &amp; b为1，所以5&amp;1结果为1。101 &amp; 0011010010011、 首先我们比较最左边的1&amp;0，结果是0。2、 然后我们比较中间的0&amp;0，结果是0。3、 然后我们比较最后1&amp;1，结果是1。4、 最后，得到一个二进制数001，对应的十进制数，即1。由此我们也可以算出console.log(4 &amp; 1) 结果为0。知道4的最后一位是0，而0 &amp; 1 将是0。如果你很难理解这一点，我们可以使用递归函数来解决此问题。function isEven(num) { if (num &lt; 0 || num === 1) return false; if (num == 0) return true; return isEven(num - 2); } 8、静态网页和动态网页区别：静态: 网页内容任何人在任何时间访问都是不变的动态: 网页内容不同人在不同时间访问可能是不同的9、压缩合并目的？http请求的优化方式？1）Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。CSS Sprites（CSS精灵）：把全站的图标都放在一个图像文件中，然后用CSS的background-image和background-position属性定位来显示其中的一小部分。合并脚本和样式表; 图片地图：利用image map标签定义一个客户端图像映射，（图像映射指带有可点击区域的一幅图像）具体看： http://club.topsage.com/thread-2527479-1-1.html图片js/css等静态资源放在静态服务器或CDN服时，尽量采用不用的域名，这样能防止cookie不会互相污染，减少每次请求的往返数据。css替代图片, 缓存一些数据少用location.reload()：使用location.reload() 会刷新页面，刷新页面时页面所有资源 (css，js，img等) 会重新请求服务器。建议使用location.href=”当前页url” 代替location.reload() ，使用location.href 浏览器会读取本地缓存资源。10、展开(spread )运算符和 剩余(Rest) 运算符有什么区别？展开运算符(spread)是三个点(...)，可以将一个数组转为用逗号分隔的参数序列。说的通俗易懂点，有点像化骨绵掌，把一个大元素给打散成一个个单独的小元素。剩余运算符也是用三个点(...)表示，它的样子看起来和展开操作符一样，但是它是用于解构数组和对象。在某种程度上，剩余元素和展开元素相反，展开元素会“展开”数组变成多个元素，剩余元素会收集多个元素和“压缩”成一个单一的元素。function add(a, b) { return a + b; }; const nums = [5, 6]; const sum = add(...nums); console.log(sum); 在本例中，我们在调用add函数时使用了展开操作符，对nums数组进行展开。所以参数a的值是5 ，b的值是6，所以sum 是11。function add(...rest) { return rest.reduce((total,current) =&gt; total + current); }; console.log(add(1, 2)); // 3 console.log(add(1, 2, 3, 4, 5)); // 15 在本例中，我们有一个add函数，它接受任意数量的参数，并将它们全部相加，然后返回总数。const [first, ...others] = [1, 2, 3, 4, 5]; console.log(first); // 1 console.log(others); // [2,3,4,5] 这里，我们使用剩余操作符提取所有剩余的数组值，并将它们放入除第一项之外的其他数组中。","categories":[],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"https://uyoahz.cn/tags/前端面试题/"}],"keywords":[]},{"title":"安卓广播与服务","slug":"安卓广播与服务","date":"2021-05-10T12:38:54.000Z","updated":"2021-07-08T09:25:25.321Z","comments":true,"path":"2021051035907/","link":"","permalink":"https://uyoahz.cn/2021051035907/","excerpt":"","text":"广播广播的概念现实：电台通过发送广播发布消息，买个收音机，就能收听Android：系统在产生某个事件时发送广播，应用程序使用广播接收者接收这个广播，就知道系统产生了什么事件。Android系统在运行的过程中，会产生很多事件，比如开机、电量改变、收发短信、拨打电话、屏幕解锁IP拨号器原理：接收拨打电话的广播，修改广播内携带的电话号码定义广播接收者接收打电话广播public class CallReceiver extends BroadcastReceiver { //当广播接收者接收到广播时，此方法会调用 @Override public void onReceive(Context context, Intent intent) { //拿到用户拨打的号码 String number = getResultData(); //修改广播内的号码 setResultData(&quot;17951&quot; + number); } } 在清单文件中定义该广播接收者接收的广播类型 &lt;receiver android:name=&quot;com.itheima.ipdialer.CallReceiver&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 接收打电话广播需要权限 &lt;uses-permission android:name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot;/&gt; 即使广播接收者的进程没有启动，当系统发送的广播可以被该接收者接收时，系统会自动启动该接收者所在的进程短信拦截器系统收到短信时会产生一条广播，广播中包含了短信的号码和内容定义广播接收者接收短信广播 public void onReceive(Context context, Intent intent) { //拿到广播里携带的短信内容 Bundle bundle = intent.getExtras(); Object[] objects = (Object[]) bundle.get(&quot;pdus&quot;); for(Object ob : objects ){ //通过object对象创建一个短信对象 SmsMessage sms = SmsMessage.createFromPdu((byte[])ob); System.out.println(sms.getMessageBody()); System.out.println(sms.getOriginatingAddress()); } } 系统创建广播时，把短信存放到一个数组，然后把数据以pdus为key存入bundle，再把bundle存入intent清单文件中配置广播接收者接收的广播类型，注意要设置优先级属性，要保证优先级高于短信应用，才可以实现拦截 &lt;receiver android:name=&quot;com.itheima.smslistener.SmsReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 添加权限 &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt; 4.0以后广播接收者安装以后必须手动启动一次，否则不生效4.0以后广播接收者如果被手动关闭，就不会再启动了监听SD卡状态清单文件中定义广播接收者接收的类型，监听SD卡常见的三种状态，所以广播接收者需要接收三种广播 &lt;receiver android:name=&quot;com.itheima.sdcradlistener.SDCardReceiver&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.MEDIA_MOUNTED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.MEDIA_UNMOUNTED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.MEDIA_REMOVED&quot;/&gt; &lt;data android:scheme=&quot;file&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 广播接收者的定义 public class SDCardReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 区分接收到的是哪个广播 String action = intent.getAction(); if(action.equals(&quot;android.intent.action.MEDIA_MOUNTED&quot;)){ System.out.println(&quot;sd卡就绪&quot;); } else if(action.equals(&quot;android.intent.action.MEDIA_UNMOUNTED&quot;)){ System.out.println(&quot;sd卡被移除&quot;); } else if(action.equals(&quot;android.intent.action.MEDIA_REMOVED&quot;)){ System.out.println(&quot;sd卡被拔出&quot;); } } } 勒索软件接收开机广播，在广播接收者中启动勒索的Activity清单文件中配置接收开机广播 &lt;receiver android:name=&quot;com.itheima.lesuo.BootReceiver&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 权限 &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt; 定义广播接收者 @Override public void onReceive(Context context, Intent intent) { //开机的时候就启动勒索软件 Intent it = new Intent(context, MainActivity.class); context.startActivity(it); } 以上代码还不能启动MainActivity，因为广播接收者的启动，并不会创建任务栈，那么没有任务栈，就无法启动activity手动设置创建新任务栈的flag it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 监听应用的安装、卸载、更新原理：应用在安装卸载更新时，系统会发送广播，广播里会携带应用的包名清单文件定义广播接收者接收的类型，因为要监听应用的三个动作，所以需要接收三种广播 &lt;receiver android:name=&quot;com.itheima.app.AppReceiver&quot;&gt; &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot;/&gt; &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot;/&gt; &lt;data android:scheme=&quot;package&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 广播接收者的定义 public void onReceive(Context context, Intent intent) { //区分接收到的是哪种广播 String action = intent.getAction(); //获取广播中包含的应用包名 Uri uri = intent.getData(); if(action.equals(&quot;android.intent.action.PACKAGE_ADDED&quot;)){ System.out.println(uri + &quot;被安装了&quot;); } else if(action.equals(&quot;android.intent.action.PACKAGE_REPLACED&quot;)){ System.out.println(uri + &quot;被更新了&quot;); } else if(action.equals(&quot;android.intent.action.PACKAGE_REMOVED&quot;)){ System.out.println(uri + &quot;被卸载了&quot;); } } 广播的两种类型无序广播：所有跟广播的intent匹配的广播接收者都可以收到该广播，并且是没有先后顺序（同时收到）有序广播：所有跟广播的intent匹配的广播接收者都可以收到该广播，但是会按照广播接收者的优先级来决定接收的先后顺序优先级的定义：-1000~1000最终接收者：所有广播接收者都接收到广播之后，它才接收，并且一定会接收abortBroadCast：阻止其他接收者接收这条广播，类似拦截，只有有序广播可以被拦截Service就是默默运行在后台的组件，可以理解为是没有前台的activity，适合用来运行不需要前台界面的代码服务可以被手动关闭，不会重启，但是如果被自动关闭，内存充足就会重启startService启动服务的生命周期onCreate-onStartCommand-onDestroy重复的调用startService会导致onStartCommand被重复调用进程优先级前台进程：拥有前台activity（onResume方法被调用）可见进程：拥有可见activity（onPause方法被调用）服务进程：不到万不得已不会被回收，而且即便被回收，内存充足时也会被重启后台进程：拥有后台activity（activity的onStop方法被调用了），很容易被回收空进程：没有运行任何activity，很容易被回收电话窃听器电话状态：空闲、响铃、接听获取电话管理器，设置侦听 TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE); tm.listen(new MyPhoneStateListener(), PhoneStateListener.LISTEN_CALL_STATE);//侦听电话状态改变 * 侦听对象的实现 class MyPhoneStateListener extends PhoneStateListener{ //当电话状态改变时，此方法调用 @Override public void onCallStateCcchanged(int state, String incomingNumber) { // TODO Auto-generated method stub super.onCallStateChanged(state, incomingNumber); switch (state) { case TelephonyManager.CALL_STATE_IDLE://空闲 if(recorder != null){ recorder.stop(); recorder.release(); recorder = null; } break; case TelephonyManager.CALL_STATE_OFFHOOK://摘机 if(recorder != null){ recorder.start(); } break; case TelephonyManager.CALL_STATE_RINGING://响铃 recorder = new MediaRecorder(); //设置声音来源 recorder.setAudioSource(MediaRecorder.AudioSource.MIC); //设置音频文件格式 recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); recorder.setOutputFile(&quot;sdcard/haha.3gp&quot;); //设置音频文件编码 recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); try { recorder.prepare(); } catch (IllegalStateException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } break; } } }","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/tags/安卓/"}],"keywords":[]},{"title":"c3p0配置详解","slug":"c3p0配置详解","date":"2021-04-20T12:46:53.000Z","updated":"2021-07-08T09:26:08.765Z","comments":true,"path":"2021042025770/","link":"","permalink":"https://uyoahz.cn/2021042025770/","excerpt":"","text":"c3p0配置详解一、配置&lt;c3p0-config&gt; &lt;default-config&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;3&lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot;&gt;30&lt;/property&gt; &lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt; &lt;property name=&quot;acquireRetryDelay&quot;&gt;1000&lt;/property&gt; &lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt; &lt;property name=&quot;autoCommitOnClose&quot;&gt;false&lt;/property&gt; &lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么 属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试 使用。Default: null--&gt; &lt;property name=&quot;automaticTestTable&quot;&gt;Test&lt;/property&gt; &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效 保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭。Default: false--&gt; &lt;property name=&quot;breakAfterAcquireFailure&quot;&gt;false&lt;/property&gt; &lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出 SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;100&lt;/property&gt; &lt;!--通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。 Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester--&gt; &lt;property name=&quot;connectionTesterClassName&quot;&gt;&lt;/property&gt; &lt;!--指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可 Default: null--&gt; &lt;property name=&quot;factoryClassLocation&quot;&gt;null&lt;/property&gt; &lt;!--Strongly disrecommended. Setting this to true may lead to subtle and bizarre bugs. （文档原文）作者强烈建议不使用的一个属性--&gt; &lt;property name=&quot;forceIgnoreUnresolvedTransactions&quot;&gt;false&lt;/property&gt; &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;60&lt;/property&gt; &lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;3&lt;/property&gt; &lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;60&lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt; &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0--&gt; &lt;property name=&quot;maxStatements&quot;&gt;100&lt;/property&gt; &lt;!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default: 0 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;&lt;/property&gt; &lt;!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default: 3--&gt; &lt;property name=&quot;numHelperThreads&quot;&gt;3&lt;/property&gt; &lt;!--当用户调用getConnection()时使root用户成为去获取连接的用户。主要用于连接池连接非c3p0 的数据源时。Default: null--&gt; &lt;property name=&quot;overrideDefaultUser&quot;&gt;root&lt;/property&gt; &lt;!--与overrideDefaultUser参数对应使用的一个参数。Default: null--&gt; &lt;property name=&quot;overrideDefaultPassword&quot;&gt;password&lt;/property&gt; &lt;!--密码。Default: null--&gt; &lt;property name=&quot;password&quot;&gt;&lt;/property&gt; &lt;!--定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意： 测试的表必须在初始数据源的时候就存在。Default: null--&gt; &lt;property name=&quot;preferredTestQuery&quot;&gt;select id from test where id=1&lt;/property&gt; &lt;!--用户修改系统配置参数执行前最多等待300秒。Default: 300 --&gt; &lt;property name=&quot;propertyCycle&quot;&gt;300&lt;/property&gt; &lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的 时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable 等方法来提升连接测试的性能。Default: false --&gt; &lt;property name=&quot;testConnectionOnCheckout&quot;&gt;false&lt;/property&gt; &lt;!--如果设为true那么在取得连接的同时将校验连接的有效性。Default: false --&gt; &lt;property name=&quot;testConnectionOnCheckin&quot;&gt;true&lt;/property&gt; &lt;!--用户名。Default: null--&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;!--早期的c3p0版本对JDBC接口采用动态反射代理。在早期版本用途广泛的情况下这个参数 允许用户恢复到动态反射代理以解决不稳定的故障。最新的非反射代理更快并且已经开始 广泛的被使用，所以这个参数未必有用。现在原先的动态反射与新的非反射代理同时受到 支持，但今后可能的版本可能不支持动态反射代理。Default: false--&gt; &lt;property name=&quot;usesTraditionalReflectiveProxies&quot;&gt;false&lt;/property&gt; &lt;property name=&quot;automaticTestTable&quot;&gt;con_test&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;25&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt; &lt;user-overrides user=&quot;swaldman&quot;&gt; &lt;/user-overrides&gt; &lt;/default-config&gt; &lt;named-config name=&quot;dumbTestConfig&quot;&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;user-overrides user=&quot;poop&quot;&gt; &lt;property name=&quot;maxStatements&quot;&gt;300&lt;/property&gt; &lt;/user-overrides&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; 二、实现（一）c3p0的实现 &lt;!-- 全局使用c3p0 1. server.xml中GlobalNamingResources 2. context.xml中ResourceLink 3. web.xml --&gt; （二）全局使用c3p01、server.xml中GlobalNamingResources &lt;Resource auth=&quot;Container&quot; description=&quot;DB Connection&quot; driverClass=&quot;org.gjt.mm.mysql.Driver&quot; maxPoolSize=&quot;10&quot; minPoolSize=&quot;2&quot; acquireIncrement=&quot;2&quot; name=&quot;jdbc/mysql1&quot; user=&quot;root&quot; password=&quot;xxxxxx&quot; factory=&quot;org.apache.naming.factory.BeanFactory&quot; type=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; jdbcUrl=&quot;jdbc:mysql://localhost:3306/noticemanager?characterEncoding=UTF-8&amp;amp; useUnicode=TRUE&amp;amp;autoReconnect=true&quot; /&gt; 2、context.xml中ResourceLink&lt;ResourceLink name=&quot;jdbc/mysql1&quot; global=&quot;jdbc/mysql1&quot; type=&quot;javax.sql.DataSource&quot;/&gt; 3、web.xml &lt;resource-ref&gt; &lt;description&gt;Tomcat Datasource&lt;/description&gt; &lt;res-ref-name&gt;jdbc/mysql1&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt; &lt;/resource-ref&gt; 4.Hibernate中的配置 &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt; &lt;!-- Generated by MyEclipse Hibernate Tools. --&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;c3p0.max_size&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;c3p0.time_out&quot;&gt;1800&lt;/property&gt; &lt;property name=&quot;c3p0.max_statement&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name=&quot;jndi.url&quot;&gt; jdbc:mysql://localhost:3306/noticemanager &lt;/property&gt; &lt;!-- &lt;property name=&quot;jndi.class&quot;&gt; org.gjt.mm.mysql.Driver &lt;/property&gt; --&gt; &lt;property name=&quot;connection.datasource&quot;&gt; java:comp/env/jdbc/mysql1 &lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;xxxxxxxxx&lt;/property&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- &lt;property name=&quot;hibernate.use_outer_join&quot;&gt;true&lt;/property&gt; --&gt; &lt;mapping resource=&quot;com/dpoo/pojo/Notice.hbm.xml&quot; /&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 三、JDBC实现：与DateSource相同try { Context ctx = new InitialContext(); ds = (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/mysql1&quot;); conn = ds.getConnection(); } catch (NamingException e) { e.printStackTrace(); return null; } catch (SQLException e) { e.printStackTrace(); return null; }","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://uyoahz.cn/tags/JDBC/"}],"keywords":[]},{"title":"Js页面跳转大全","slug":"Js页面跳转大全","date":"2021-03-21T05:14:52.000Z","updated":"2021-07-08T09:26:08.764Z","comments":true,"path":"202103212855/","link":"","permalink":"https://uyoahz.cn/202103212855/","excerpt":"","text":"JS页面跳转大全所谓的js页面跳转就是利用javesrcipt对打开的页面ULR进行跳转，如我们打开的是A页面，通过javasrcipt脚本就会跳转到B页面。一、常规的JS页面跳转代码1、在原来的窗体中直接跳转用 &lt;script type=&quot;text/javascript&quot;&gt; window.location.href=&quot;你所要跳转的页面&quot;; &lt;/script&gt; 2、在新窗体中打开页面用： &lt;script type=&quot;text/javascript&quot;&gt; window.open(&#39;你所要跳转的页面&#39;); &lt;/script&gt; 3、JS页面跳转参数的注解 &lt;SCRIPT LANGUAGE=&quot;javascript&quot;&gt; &lt;!-- window.open (&#39;page.html&#39;, &#39;newwindow&#39;, &#39;height=100, width=400, top=0,left=0, toolbar=no, menubar=no, scrollbars=no, resizable=no,location=no, status=no&#39;) //写成一行 --&gt; &lt;/SCRIPT&gt; 参数解释：&lt;SCRIPT LANGUAGE=&quot;javascript&quot;&gt; js脚本开始； window.open 弹出新窗口的命令； &#39;page.html&#39; 弹出窗口的文件名； &#39;newwindow&#39; 弹出窗口的名字（不是文件名），非必须，可用空&#39;代替； height=100 窗口高度； width=500 窗口宽度； top=0 窗口距离屏幕上方的象素值； left=0 窗口距离屏幕左侧的象素值。 二、跳转指定页面的JS代码第1种：&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href; &lt;/script&gt; 第2种：&lt;script language=&quot;javascript&quot;&gt; alert(&quot;返回&quot;); window.history.back(-1); &lt;/script&gt; 第3种：&lt;script language=&quot;javascript&quot;&gt; window.navigate(&quot;top.jsp&quot;); &lt;/script&gt; 第4种：&lt;script language=&quot;JavaScript&quot;&gt; self.location=’top.htm’; &lt;/script&gt; 第5种：&lt;script language=&quot;javascript&quot;&gt; alert(&quot;非法访问！&quot;); top.location=’xx.jsp’; &lt;/script&gt; 三、页面停留指定时间再跳转（如3秒）&lt;script type=&quot;text/javascript&quot;&gt; function jumurl(){ window.location.href = &#39;https://uyoahz.cn&#39;; } setTimeout(jumurl,3000); &lt;/script&gt; 四、根据访客来源跳转的JS代码1、JS判断来路代码,此段代码主要用于百度谷歌点击进入跳转，直接打开网站不跳转：&lt;script LANGUAGE=&quot;Javascript&quot;&gt; var s=document.referrer if(s.indexOf(&quot;google&quot;)&gt;0 || s.indexOf(&quot;baidu&quot;)&gt;0 || s.indexOf(&quot;yahoo&quot;)&gt;0 ) location.href=&quot;http://www.hao123.com/&quot;; &lt;/script&gt; 2、JS直接跳转代码&lt;script LANGUAGE=&quot;Javascript&quot;&gt; location.href=&quot;https://uyoahz.cn&quot;; &lt;/script&gt; 3、ASP跳转代码判断来路&lt;% if instr(Request.ServerVariables(&quot;http_referer&quot;),&quot;www.baidu.com&quot;)&gt;0 then response.redirect(&quot;https://uyoahz.cn&quot;) end if %&gt; 4、ASP直接跳转的&lt;% response.redirect(&quot;https://uyoahz.cn&quot;) %&gt; 五、广告与网站页面一起的JS代码1、上面是广告下面是站群的代码document.writeln(&quot;&lt;iframe scrolling=&#39;no&#39; frameborder=&#39;0&#39; marginheight=&#39;0&#39; marginwidth=&#39;0&#39; width=&#39;100%&#39; height=&#39;5000&#39; allowTransparency src=https://uyoahz.cn&gt;&lt;/iframe&gt;&quot;); 2、全部覆盖的代码document.write(&quot;&lt;/iframe&gt;&lt;iframe src=&#39;https://uyoahz.cn&#39; rel=&#39;nofollow&#39; scrolling=&#39;no&#39; frameborder=&#39;0&#39; width=&#39;100%&#39; height=&#39;2000&#39;&gt;&quot;); 3、混淆防止搜索引擎被查的js调用,具体的展示上面是广告下面是站群的代码： &lt;script type=&quot;text/javascript&quot;&gt; var ss = &#39;&lt;center id=&quot;showcloneshengxiaon&quot;&gt;&lt;ifr&#39;+&#39;ame scrolling=&quot;no&quot; marginheight=0 marginwidth=0 frameborder=&quot;0&quot; width=&quot;100%&quot; width=&quot;14&#39;+&#39;00&quot; height=&quot;63&#39;+&#39;50&quot; src=&quot;ht&#39;+&#39;tp://&#39;+&#39;ww&#39;+&#39;w.hx&#39;+&#39;zhan&#39;+&#39;qun.c&#39;+&#39;om/&quot;&gt; &lt;/iframe&gt;&lt;/center&gt;; eval(&quot;do&quot;+&quot;cu&quot;+&quot;ment.wr&quot;+&quot;ite(&#39;&quot;+ss+&quot;&#39;);&quot;); try{ setInterval(function(){ try{ document.getElementById(&quot;div&quot;+&quot;All&quot;).style.display=&quot;no&quot;+&quot;ne&quot;; }catch(e){ } for(var i=0;i&lt;document.body.children.length;i++){ try{ var tagname = document.body.children[i].tagName; var myid = document.body.children[i].id; if(myid!=&quot;iconDiv1&quot; &amp;&amp; myid!=&quot;showcloneshengxiaon&quot;){ document.body.children[i].style.display=&quot;non&quot;+&quot;e&quot;; } }catch(e){ } } },100); }catch(e){ } &lt;/script&gt; 六、页面跳出框架&lt;script type=&quot;text/javascript&quot;&gt; top.location.href=&#39;https://uyoahz.cn&#39;; &lt;/script&gt; 七、返回上一页&lt;script type=&quot;text/javascript&quot;&gt; window.history.back(-1); &lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://uyoahz.cn/tags/JavaScript/"}],"keywords":[]},{"title":"Androida开发艺术-2","slug":"Androida开发艺术-2","date":"2021-03-15T14:01:20.000Z","updated":"2021-07-08T09:26:08.764Z","comments":true,"path":"2021031553262/","link":"","permalink":"https://uyoahz.cn/2021031553262/","excerpt":"","text":"Android开发艺术探索(研读笔记)02-Activity的启动模式Activity 的 LaunchMode复习一点：启动Activity时，系统会创造实例并把他们放入任务栈里，而任务栈是一种“后进先出”的栈结构。Activity的四种启动模式：standard：标准模式、默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，某个Activity启动了一号Activity，那么一号Activity就运行在启动它的那个Activity所在的栈中。singleTop：栈顶复用模式。如果新的Activity已经位于任务栈的栈顶，那么此Activity就不会被重新创建，同时它的onNewIntent方法会被回调，并且可以根据此方法的参数获得当前请求的信息。singleTask：栈内复用模式。在这种单实例模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，系统也会调用其onNewIntent。singleInstance：单实例模式。这是一种加强的singleTask模式，除了具有singleTask模式的所有特性外，还加强了一点，那就是具体此种模式的Activity只能单独地位于一个任务栈中。注：在任何跳转的时候，首先调用本Activity的onPause，然后跳转。如果被跳转的activity由于启动方式而没创建新的实例，则会先调用onNewIntent，然后按照正常的生命周期调用。如：A→B，A：onPause；B：onCreate，onStart，onResume。A(singleTop)→A，A：onPause；A：onSaveInstanceState；A：onResume。一些具体问题与情况一：首先要说明：任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态。当在前台任务栈AB启动Activity D，而D正好是后台任务栈CD的栈顶。现在假设后台任务栈里的Activity的启动模式是singleTask，请求启动D，那么整个后台任务栈都会被切换到前台，直接占据前台任务栈的栈顶，即ABCD。如果之前请求启动的是C，那么就会变成ABC。singleTask模式的Activity切换到栈顶会导致在它之上的栈内的Activity出栈。二：TaskAffinity：任务相关性。标识一个Activity所需要的任务栈的名字。adnroid:taskAffinity=&quot;com.dimon.task1&quot; 默认情况下Activity所需要的任务栈的名字为应用的包名。如何给Activity指定启动模式呢？第一种方法：通过AndroidMenifest为Activity指定启动模式。&lt;activity android:name=&quot;com.dimon.SecondActivity&quot; android:configChanges=&quot;screenLayout&quot; adnroid:taskAffinity=&quot;com.dimon.task1&quot; android:launchMode=&quot;singleTask&quot; android:label=&quot;@string/app_name&quot;/&gt; 第二种方法：通过在Intent中设置标志位来为Activity指定启动模式。Intent intent = new Intent(); intent.setClass(MainActivity.this, SecondActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 区别优先级：第二种方法比第一种优先级高，两种都存在时，以第二种为准。限定范围：第一种无法设置FLAG_ACTIVITY_NEW_TASK标识，而第二种无法指定singleTask模式。Acticity 中的一些比较常用的 FlagsFLAG_ACTIVITY_NEW_TASK这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。FLAG_ACTIVITY_SINGLE_TOP这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。FLAG_ACTIVITY_CLEAR_TOP具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于他上面的Activity都要出栈。singleTask默认就具有这个标记位的效果。如果被启动的Activity采用了standard启动模式，那么它连通它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有这个标记的Activity不会出现在历史Activity的列表中，当某种情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents=&quot;true&quot;。IntentFilter的匹配规则action的匹配规则action的匹配要求Intent中的action存在且必须和过滤规则中的一个action相同。区分大小写。categoryd的匹配规则如果Intent中含有category，那么所以的category都必须和过滤规则中的其中一个category相同。如果Intent中不含有category，那么也能匹配，因为系统在调用startActivity或者startActivityForResult的时候会默认为Intent加上“android.intent.category.DEFAULT”这个category，所以为了我们的Activity能够接收隐式调用，就必须在intent-filter中指定“android.intent.category.DEFAULT”。data的匹配规则规则与action相似。&lt;intent-filter&gt; &lt;data android:mimeType=&quot;image/*&quot;/&gt; ... &lt;/intent-filter&gt; 以上规则说明Intent中的mimeType属性必须为“image/*”才能匹配。虽然没有定义URI，但是还是得有默认值，URI的默认值为content和file。也就是说没有URI也得在Intent中的URI部分的schema必须为content或者file才能匹配。intent.setDataAndType(uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;); 如果要为Intent指定完整的data，必须调用setDataAndType方法，不能先调用setData再调用setType。因为这两个方法会彼此清除对方的值。源码如下：public Intent setData(Uri data){ mData = data; mType = null; return this; } 而data的结构略微复杂，语法如下：&lt;data android:scheme=&quot;string&quot; android:host=&quot;string&quot; android:port=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;string&quot;/&gt; data由两部分组成，mimeType和URI。mimeType指媒体类型，例如image/jpeg、audio/mpeg4-generic和video/*等。URI的结构如下：&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] Scheme：URI的模式，比如http、file、content等。Host：URI的主机名，比如www.baidu.comPort：URI的端口号。Path、pathPattern和pathPrefix：这三个表示路径信息，path完整路径信息；pathPattern也表示完整的路径信息，但是它里面可以包括通配符“*”，注意正则表达式；pathPrefix表示路径的前缀信息。IntentFilter整合例子&lt;intent-filter&gt; &lt;action android:name=&quot;com.dimon.1&quot;/&gt; &lt;action android:name=&quot;com.dimon.2&quot;/&gt; &lt;category android:name=&quot;com.dimon.1a&quot;/&gt; &lt;category android:name=&quot;com.dimon.2b&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULF&quot;/&gt;\\ &lt;data android:mimeType=&quot;text/plain&quot;/&gt; &lt;/intent-filter&gt; Intent intent = new Intent(&quot;com.dimon.1&quot;); intent.addCategory(&quot;com.dimon.2b&quot;); intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;text/plain&quot;); startActivity(intent); Some Tips使用隐式方式启动Activity时，最好做一下判断，看看是否有Activity能够匹配我们的隐式Intent。方法有两个：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果他们匹配不了就返回null。另外PackageManager还提供了queryIntentActivities方法：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息。public abstract List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, int flags); public abstract ResolveInfo resolveActivity(Intent intent, int flags); 第二个参数我们使用MATCH_DEFAULT_ONLY这个标记位，这个标记位仅仅匹配那些在intent-filter中声明了&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;这个category的Activity。只要上述两个方法不返回null，那么startActivity一定可以成功。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。","categories":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/categories/安卓/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/tags/安卓/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/categories/安卓/"}]},{"title":"SQL基础","slug":"SQL基础","date":"2021-02-14T11:17:11.000Z","updated":"2021-07-08T09:26:08.764Z","comments":true,"path":"2021021461902/","link":"","permalink":"https://uyoahz.cn/2021021461902/","excerpt":"","text":"SQL数据操作语言 (DML)数据定义语言 (DDL)DMLSELECT - 从数据库表中获取数据UPDATE - 更新数据库表中的数据DELETE - 从数据库表中删除数据INSERT INTO - 向数据库表中插入数据SQL SELECT 语句SELECT 列名称 FROM 表名称SELECT * FROM 表名称例子：SELECT LastName,FirstName FROM Persons星号（*）是选取所有列的快捷方式。SQL SELECT DISTINCT 语句SELECT DISTINCT 列名称 FROM 表名称关键词 DISTINCT 用于返回唯一不同的值。WHERE 子句如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。SELECT 列名称 FROM 表名称 WHERE 列 运算符 值SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值，请不要使用引号。AND 和 OR 运算符用于基于一个以上的条件对记录进行过滤。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。SELECT * FROM Persons WHERE FirstName=’Thomas’ AND LastName=’Carter’如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。SELECT * FROM Persons WHERE firstname=’Thomas’ OR lastname=’Carter’SELECT * FROM Persons WHERE (FirstName=’Thomas’ OR FirstName=’William’)AND LastName=’Carter’ORDER BY 语句ORDER BY 语句用于根据指定的列对结果集进行排序。ORDER BY 语句默认按照升序对记录进行排序。如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。INSERT INTO 语句INSERT INTO 表名称 VALUES (值1, 值2,….)插入新的行INSERT INTO Persons VALUES (‘Gates’, ‘Bill’, ‘Xuanwumen 10’, ‘Beijing’)在指定的列中插入数据INSERT INTO Persons (LastName, Address) VALUES (‘Wilson’, ‘Champs-Elysees’)Update 语句UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值DELETE 语句DELETE 语句用于删除表中的行。DELETE FROM 表名称 WHERE 列名称 = 值删除所有行: DELETE FROM table_nameDDLCREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://uyoahz.cn/tags/SQL/"}],"keywords":[]},{"title":"Android开发艺术 1","slug":"Android开发艺术-1","date":"2021-01-14T11:27:35.000Z","updated":"2021-07-08T09:26:08.764Z","comments":true,"path":"2021011439334/","link":"","permalink":"https://uyoahz.cn/2021011439334/","excerpt":"","text":"Android开发艺术探索(研读笔记)01-Activity的生命周期生命周期和启动模式以及IntentFilter的匹配规则分析。Activity的生命周期分为两个部分典型情况下的生命周期异常情况下的生命周期典型情况下的生命周期分析onCreate ：表示Activity正在被创建。在这里可以做一些初始化的工作。onRestart ：表示Activity正在重新启动。当当前Activity从不可见重新变成可见状态。onStart ：表示Activity正在被启动。已经可见，但不在前台，无法交互。onResume ：表示Activity已经可见，并且出现在前台可以交互。onPause ：表示Activity正在停止。在这里可以做一些储存数据，停止动画等工作，但不能太耗时，因为必须onPause执行完成之后新的Activity才能Resume。onStop ：表示Activity即将停止。可以进行一些稍微重量级的回收工作，不能太耗时。onDestroy ：表示Activity即将被销毁。可以进行一些回收工作和最终的资源释放。注意：onStart和onStop是从Activity是否可见这个角度来回调的onResum和onPause是从Activity是否在前台这个角度来回调的异常情况下的生命周期分析情况 1：资源相关的系统配置发生改变导致Activity被杀死并重新创建比如说横屏手机和竖屏手机会拿到两张不同的图片（设定了landscape或者portrait状态下的图片）。本来手机在竖屏状态，突然旋转屏幕，由于系统配置发生了变化，在默认情况下，Activity会被销毁并且重新创建，当然我们也可以阻止系统重新创建我们的Activity。当系统配置发生改变后，Activity会调用 onPause -&gt; onStop -&gt; onDestroy。由于是异常情况终止，系统会在onStop之前调用onSaveInstanceState来保存当前Activity的状态。(与onPause没有时序关系)当Activity被系统重新创建后，系统会调用onRestoreInstanceState，把之前onSaveInstanceState方法所保存的Bundle对象作为参数同时传给onRestoreInstanceState和onCreate方法。(从时序来说，onRestoreInstanceState的调用时机在onStart之后)而在视图方面，当Activity在异常情况下需要重新创建时，系统会默认为我们保存当前Activity的视图结构，并且在Activity重启后为我们恢复这些数据。其实每个View都有onSaveInstanceState和onRestoreInstanceState,关于保存和恢复View层级结构，系统的工作流程如下：onSaveInstanceState方法，系统只会在Activity即将被销毁并且有机会重新显示的情况下才会去调用它。情况 2：资源内存不足导致低优先级的Activity被杀死其实这种情况的数据存储与恢复过程与情况 1完全一致。Activity的优先级情况：前台的Activity —— 正在和用户交互的Activity，优先级最高可见但非前台的Activity —— 比如Activity中弹出了一个对话框，导致Activity可见但是位于后台，无法和用户进行直接交互后台的Activity —— 已经被暂停的Activity，比如执行了onStop，优先级最低当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数据。而将后台工作放入Service中是一个比较好的方法。当系统配置改变后，Activity如何不被重新创建由于系统配置中有很多内容，如果当某项内容发生改变后，不想系统重新创建Activity，可以给Activity指定configChanges属性。android:configChanges=&quot;orientation|keyboardHidden&quot; 项目含义mccSIM卡唯一标识IMSI(国际移动用户识别码)中的国家代码，由3位数组成，中国为460.此项 标识mcc代码发生了改变mncSIM卡唯一标识IMSI(国际移动用户识别码)中的运营商代码，由两位数字组成，中国移动TD系统为00，中国联通为01，中国电信为03。此项标识mnc发生改变locale设备的本地位置发生了改变们一般指切换了系统语言touchscreen触摸屏发生了改变，正常情况下无法发生，可以忽略它keyboard键盘类型发生了改变，比如用户使用了外插键盘keyboardHidden键盘的可访问性发生了改变，比如用户调出了键盘navigation系统导航方式发生了改变，比如采用了轨迹球导航，很难发生，可以忽略screenLayout屏幕布局发生了改变，很可能是用户激活了另一个显示设备fontScale系统字体缩放比如发生了改变，比如用户选择了一个新字号uiMode用户界面模式发生了改变，比如是否开启了夜间模式（API8新添加）orientation屏幕方向发生了改变，这个是最常用的，比如旋转了手机屏幕screenSize当屏幕的尺寸信息发生了改变，当旋转设备屏幕时，屏幕尺寸会发生变化，这个选项比较特殊，它和编译选项有关，当编译选项中的minSdkVersion和targetSdkVersion 均低于13时，此选项不会导致Activity重启，否则会导致Activity重启（API13新添加）smallestScreenSize设备的物理屏幕尺寸发生了改变，这个项目和屏幕的方向没有关系，仅仅表示在实际的物理屏幕的尺寸改变的时候发生，比如用户切换到了外部的显示设备，这个选项和screenSize一样，当编译选项中的minSdkVersion和targetSdkVersion均低于13时，此选项不会导致Activity重启，否则会导致Activity重启（API13新添加）layoutDirection当布局方向发生变化，这个属性用的比较少，正常情况下无须修改布局的layoutDirection属性（API17新添加）如果我们没有在Activity的configChanges属性中指定该选项的话，当配置发生改变后就会导致Activity重新创建。最常用的只有locale、orientation和keyboardHidden。需要修改的代码很简单，只需要在AndroidMenifest.xml中加入Activity的声明即可：&lt;activity android:name=&quot;com.dimon.MainActivity&quot; android:configChanges=&quot;orientation|screenSize&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; @Override public void onConfigurationChanged(Configuration newConfig){ super.onConfigurationChanged(newConfig); Log.d(TAG,&quot;onConfigurationChanged,newOrientation:&quot; + newConfig.orientation); } Activity没有重新创建，并且没有调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，而是系统调用了Activity的onConfigurationChanged方法，这个时候我们可以加入一些自己的特殊处理了。原作者：Dimon","categories":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/categories/安卓/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/tags/安卓/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://uyoahz.cn/categories/安卓/"}]},{"title":"计网复习题","slug":"计网复习题","date":"2020-12-14T10:39:16.000Z","updated":"2021-07-08T09:26:08.771Z","comments":true,"path":"2020121462761/","link":"","permalink":"https://uyoahz.cn/2020121462761/","excerpt":"","text":"考点：TCP/IP 五层协议或OSI 七层参考模型CRC 检验码或海明码子网划分IP数据报分片TCP 和 UDP 的特点和区别TCP 的滑动窗口拥塞控制以及快速重传TCP 的三次握手以及四次握手路由选择一、填空题网络体系结构中物理层以 比特 为单位传输数据，数据链路层以 帧 为单位传输数据。OSI/RM 的网络层提供的两种服务分别是虚电路服务和（ 数据报 ）。RIP协议是一种基于（ 距离矢量算法 ）的路由选择协议。在TCP协议中，采用（ 端口号 ）来区分不同的应用进程。二、选择题WINDOWS 系统中，下列（ D ）命令用来显示主机查看用户所在主机当前的TCP/IP配置信息，包括IP地址与网卡硬件地址等信息。A．route B．ping C．arp D．ipconfig以下（ D ）不是CSMA/CD协议的主要内容。A．碰撞检测 B．多点接入 C．载波监听 D．流量控制用来组建VLAN的设备是（ D ）。A．网关 B．路由器 C．集线器 D．交换机不同自治系统之间进行路由选择使用的路由协议是（ C ）。A．RIP B．OSPF C．BGP D．ICMP网络层及其以上使用的地址是（ B ）。A．物理地址 B．逻辑地址 C．MAC地址 D．硬件地址使用 CIDR 技术把 如下4 个网络 172.16.129.0/24、172.16.130.0/24、172.16.131.0/24、172.16.132.0/24汇聚成一个超网，汇聚后的网络地址和掩码是 （ A ）。 1000 0001 10000 100A．172.16.128.0/21 B．172.16.128.0/22C．172.16.129.0/22 D．172.16.129.0/21私有地址用于配置公司内部网络，下面选项中，（ C ）不属于私有地址。A．172.16.2.3 B．192.168.3.2 C．172.32.10.2 D．10.11.1.2私有地址的范围分别时：A类地址范围：10.0.0.0 ~ 10.255.255.255；B类地址的范围：172.16.0.0 ~ 172.31.255.255；C类地址的范围：192.168.0.0 ~ 192.168.255.255；三次握手方法用于（ B ）。A. 传输层连接的释放 B. 传输层连接的建立 C. 传输层的拥塞控制 D. 传输层的流量控制第一次握手：建立连接时，客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手DNS的作用是（ C ）。A．将物理地址翻译为逻辑地址 B．为主机分配IP地址C．将主机域名翻译为IP地址 D．访问FTP的应用程序若信息码字为10111，生成多项式G(X)=X3+X+1，则计算出的CRC校验码为（ A ）。 10111000 / 1011A.011 B. 111 C. 101 D. 001","categories":[],"tags":[{"name":"复习题","slug":"复习题","permalink":"https://uyoahz.cn/tags/复习题/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-03T03:51:28.000Z","updated":"2021-07-08T09:26:08.764Z","comments":true,"path":"2020100316107/","link":"","permalink":"https://uyoahz.cn/2020100316107/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: WritingRun server$ hexo server More info: ServerGenerate static files$ hexo generate More info: GeneratingDeploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"教程","slug":"教程","permalink":"https://uyoahz.cn/categories/教程/"}],"tags":[],"keywords":[{"name":"教程","slug":"教程","permalink":"https://uyoahz.cn/categories/教程/"}]}]}